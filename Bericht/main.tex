\documentclass{article}
\usepackage{todonotes}
\usepackage{pbox}
\usepackage{tablefootnote}
\title{Disposition}
\author{Marc de Bever}
\begin{document}
\maketitle
\tableofcontents

\section{Einleitung}
Dieses Dokument ist ein Teil der Dokumentation des Projektes Imager-Emu\-lator. Dieses Projekt besteht aus drei Teilprojekten. 
Genauer gesagt besteht es aus zwei Bachelor Thesen und einem Projekt 5 (P5). 
Das P5 und eine Thesis laufen parallel und die zweite Thesis wird ein Semester später durchgeführt. Diese Dokumentation ist diejenige von der ersten Thesis, welche parallel mit dem Projekt 5 durchgeführt wird. Das Projekt 5 und die zweite Thesis wird von Fabio Nardo geschrieben und diese Dokumentation ist von mir, Marc de Bever, geschrieben. 

Das Projekt Imager-Emulator wurde von der Firma Varian Medical Systems ausgeschrieben. Das Ziel is es, einen Sensor zu emulieren. Der Sensor gibt Bilder über eine nicht standardisierte LWL Schnittstelle an einen Computer weiter. Der Computer, welcher die Bilder des Sensors entgegen nimmt, rechnet diverse Algorithmen, die unteranderem Pixelfehler erkennen und korrigieren. Jedoch kann dem Sensor nicht gesagt werden, \textit{mach mal 'nen Pixelfehler}. Daher braucht es ein Gerät, um Bilder mit Pixelfehlern zu generieren und an den Computer zu senden. Und dieses Gerät soll in diesem Projekt entwickelt werden.

Da dieses Projekt eine spezielle Konstellation hat, ist die Aufteilung der Teilprojekte wie folgt. Im P5 soll die Hardware entwickelt werden. In der ersten Thesis, also dieser Arbeit, sollen die Entwicklungsumgebungen und das FPGA-Modul in Betrieb genommen werden. Sowie sollen auch die Schnittstellen programmiert werden. Die zweite Thesis soll schlussendlich die Kommunikation mit dem Computer implementieren, die Pixelfehler in die Bilder einbauen und das ganze Projekt abschliessen.

Dieser Bericht dient zum einen dazu, dass im weiterführenden Projekt verstanden werden kann, wie die Entwicklungsumgebung und Schnittstellen funktioniert, deren Möglichkeiten und Grenzen. Zum anderen Dient er um zu diese Arbeit als Thesis zu dokumentieren. Der Bericht ist folgendermassen aufgebaut.

Das zweite Kapitel dieses Berichtes beschreibt wie das Sensorsystem der Varian aufgebaut ist. Zuerst gibt es einen groben Überblick und danach geht es genauer auf die Teilbereiche ein.
Das dritte Kapitel beschreibt wie unser System aussehen soll. Es gibt einen top-down Blick auf das Projekt. Das heisst es beinhaltet die Blockschaltbilder. Zusätzlich beschreibt es die Wahl der wichtigsten Komponenten, wie das FPGA-Modul.

Das vierte Kapitel beschreibt die Hardware, da dies die Arbeit des Projektes 5 ist, werden in diesem Kapitel nur die wichtigsten Punkte erwähnt, welche für das Programmieren relevant sind.

Das fünfte Kapitel beschreibt die Software. Diese besteht aus drei Teilen, dem Code für den Mikrocontroller, dem Code für den FPGA und dem Code für die PC-Applikation.
Das sechste Kapitel beschreibt wie zusätzliche Konfigurationen nachträglich hinzugefügt werden können.
Das siebte Kapitel beschreibt die Entwicklungsumgebung.

Und das letzte Kapitel beschreibt Funktionalitäten, welche nicht von uns entwickelt worden sind, sondern schon auf dem Modul vorhanden sind.

\section{System}
Das Projekt kann in drei Systeme unterteilt werden. Das vorhandene System von Varian ist das erste. Das zweite System ist eine Zwischenlösung um mit der Firmware Entwicklung anzufangen, ohne das die eigene Hardware schon vorhanden ist. Und das dritte System ist das endgültige System, welches das System von Varian emuliert.

\subsection{System Varian}
\begin{figure}[tb]
    \missingfigure{Blockdiagramm System Varian}
    \caption{Blockdiagramm des Systems von Varian}
    \label{fig:bd_varian}
\end{figure}

Das System der Varian besteht aus dem Imager und dem XI-Computer. Wobei diese beiden Blöcke Teil eines Röntgengerätes für medizinische Zwecke sind. Der Imager ist ein Bildsensor für Röntgenstrahlen und sendet die die gemessenen Bilder über ein LWL-Kabel zum XI-Computer. Der XI-Computer empfängt die Bilder und lässt diverse Algorithmen darüber laufen. Unter anderem auch Algorithmen zur Erkennung von Pixelfehlern. Das mit den Algorithmen bearbeitete Bild kann wiederum über Ethernet an einen PC gesendet werden.

Um die Bilder vom Sensor auszulesen, zu digitalisieren und zu übertragen, sitzt auf dem Imager ein FPGA. Dieser sendet die Bilder zum XI-Computer entweder über einen vom FPGA internen oder externen Serialisierer/Deserialisierer, kurz SerDes zu einem LWL-Modul. Der FPGA kommuniziert über einen parallelen Bus mit dem externen SerDes und der die beiden SerDes senden ein LVDS Signal zum LWL-Modul. Um zwischen den beiden SerDes auszuwählen, gehen die Tx Signale auf einen Multiplexer und die Rx Signale auf einen Demultiplexer, dieser wird der Einfachheitshalber nur Mux genannt. Das beschriebene System ist im Blockschaltbild in Figure \ref{fig:bd_varian} zu sehen.

Der Vorteil des internen SerDes ist die Geschwindigkeit. Der externe SerDes arbeitet 1.25Gbps und der interne mit 6Gbps. Die älteren Versionen des Imagers arbeiten nur mit dem externen SerDes und die neueren mit internen. Da stellt sich die Frage, wieso externe SerDes überhaupt gebraucht wird. Beim Einschalten des Imagers ist der noch nicht konfiguriert. Somit wird der externe SerDes gebraucht um den FPGA vom XI-Computer zu konfigurieren. Sobald der FPGA konfiguriert ist, schaltet dieser auf den internen SerDes um und kommuniziert mit dem XI-Computer über diesen. Welche SerDes die verschiedenen Versionen des Imagers besitzen ist in Tabelle \ref{tab:sensorVersionen} ersichtlich.

\begin{table}[tb]
    \caption{Eckdaten der verschiedenen Sensorversionen der Varian}
    \begin{tabular}{|l|l|l|l|l|}
        \hline
        \textbf{Imager} & \textbf{Auflösung} & \textbf{Pattern}$^1$ & \textbf{FPGA} & \textbf{Schnittstelle} \\
        \hline
        DMI$^2$ & 1280x1280 & \pbox[t]{10cm}{b10’1010’1010’1010’1010\\XI: 0xAAA} & \pbox[t]{10cm}{Spartan 3\\XC3S200} & externer SerDes\\
        \hline
        \pbox[t]{10cm}{RTI 1.0$^2$\\(RTI4343L)} & 1280x1280 & \pbox[t]{10cm}{b10’1010’1010’1010’1010\\XI: 0xAAA} & \pbox[t]{10cm}{Spartan 3\\XC3S200} & externer SerDes\\
        \hline
        \pbox[t]{10cm}{RTI 2.0\\(RTI4343iL)} & 3072x3072 &\pbox[t]{10cm}{b10’1010’1001’0101’0101\\XI: 0x955} & \pbox[t]{10cm}{Artix 7\\XC7A100T} & \pbox[t]{10cm}{aktuell:\\externer Serdes\\zukünftig:\\MGT(GTP)} \\
        \hline
        \pbox[t]{10cm}{RTIXL 1.0\\(RTI8643L)} & 6144x3072 & \pbox[t]{10cm}{b10’1010’1001’1001’0101\\XI: 0x995} & \pbox[t]{10cm}{Artix 7\\XC7A200T} & \pbox[t]{10cm}{externer SerDes\\und MGT(GTP)}\\
        \hline
       \end{tabular}
       \begin{tabular}{l}
        $^1$\pbox[t]{10cm}{Das XI wertet nur die letzten 12 bit des Pattern aus. Um das DC-Balancing zu erreichen, müssen trotzdem alle 18 bits korrekt gesendet werden.}\\
        $^2$DMI und RTI 1.0 besitzen exakt die gleiche Elektronik.

       \end{tabular}
    \label{tab:sensorVersionen}
    \end{table}

\subsubsection*{Bootvorgang}


\subsubsection*{Kommunikation zwischen Imager und XI-Computer}

Man kann zwischen dem XI-Computer und dem Imager von einer Master-Slave Beziehung reden. Der XI-Computer hat die Möglichkeit dem Imager verschiedene Befehle zu senden, welche der Imager daraufhin ausführt. Die Befehle können in drei Gruppen eingeteilt werden. Es gibt die Write-Befehle, welche dem Imager Einstellungen übermitteln, die der Imager in einem Register speichert. Mit den Read-Befehlen kann der XI-Computer diese Einstellungsregister wieder auslesen. Und als letztes gibt es noch den Trigger-Befehl. Die Write-Befehle beinhalten eine Adresse und einen Wert, die Read-Befehle nur einen Wert. Mit dem Trigger-Befehl kann der XI-Computer ein Bild anfordern. Dies hat Vorrang vor Write- und Read-Befehlen. Die genaue Auflistung aller Enstellungsregister und deren Aufgabe kann in der Dokumentation des Imagers entnommen werden. \todo{auf Imager Dokumentation referenzieren}

Der FPGA liest immer Zeile für Zeile die Werte des Sensors aus. Solange kein Trigger-Befehl vom XI-Computer gesendet wird, werden die Werte verworfen. Sobald ein Trigger-Befehl kommt, wartet der FPGA bis er die letzte Zeile ausgelesen hat und verwirft auch diese noch. Wenn der FPGA nun endlich wieder bei der ersten Zeile angelangt, fängt er an das Bild Pixel für Pixel, Zeile für Zeile zu übertragen. Am Anfang des Bildes vor der ersten Zeile sendet der FPGA ein \textit{Frame-Start} Signal. Und vor jeder Zeile überträgt er ein \textit{Line-Start} Signal. Vor der ersten Zeile muss kein zusätzliches Line-Start Signal gesendet werden. Pro Takt wird ein Pixel übertragen. Der FPGA überträgt eine Zeile erst wenn er sie vollständig vom Sensor ausgelesen hat. Somit bleibt zwischen den zu übertragenden Zeilen noch Zeit um etwaige Read-Befehle auszuführen.

Die Read-Befehle werden nur ausgeführt, wenn keine Bilddaten zu senden sind. Daher werden sie in einem FIFO zwischengespeichert und bei Möglichkeit übertragen. Die Read-Befehle dürfen nur zwischen den Zeilen und Bildern übertragen werden und nicht zwischen einzelnen Pixeln. Da es länger dauert eine Zeile von Sensor zu lesen, als eine Zeile an den XI-Computer zu senden, bleibt immer etwas Zeit um die Read-Befehle vom FIFO abzuarbeiten. Wie vor einem neuen Bild und einer neuen Zeile gibt es das \textit{Command} Signal, welches vor den Daten des Read-Befehls gesendet wird. Die Daten eines Read-Befehls bestehen aus den Daten aus dem Einstellungsregister.

\subsubsection*{Wahl des FPGAs}
- Einleitung
- Anforderungen
    - 4GB ram
    - Usb
    -> Modul mit aufgebautem RAM
- Vorschläge
- Auswahl
    - Grund wieso XU5
    - Einschränkungen, weil falsche Modulversion
\subsubsection*{Enclustra Mercury XU5 SoC}
\begin{figure}[tb]
    \missingfigure{Blockdiagramm des XU5}
    \caption{Blockdiagramm SoC Moduls XU5 von Enclustra}
    \label{fig:bd_xu5}
\end{figure}
- Blockdiagram erklären
    - Nur Blöcke, welche wir auch brauchen
    - DDR4 Ram 2x
    - Ultrascale

\subsubsection*{Xilinx Zynq Ultrascale+}
\begin{figure}[tb]
    \missingfigure{Blockdiagramm des SoCs}
    \caption{Blockdiagramm des Zynq Ultrascale+ SoCs von Xilinx}
    \label{fig:bd_soc}
\end{figure}
- Hardcore Processor System
- Konfigurierbare Logic(FPGA)
- Referenz auf Doku

\subsection{Entwicklungssystem}
- Hardware für xu5 
    -> da hardware gleichzeitig entwickelt wird
    - PE1

\subsubsection*{Mercury+ PE1-200 Baseboard}
\begin{figure}[tb]
    \missingfigure{Blockdiagramm des Baseboards}
    \caption{Blockdiagramm des Mercury+ PE1-200 Baseboards von Enclustra}
    \label{fig:bd_pe1}
\end{figure}

- Blockdiagram erklären
    - Nur Blöcke, welche wir auch brauchen
    - SD
    - USB
    - JTAG
    - UART
    - IO
        - Dip configuration
            - Boot
- Referenz auf Doku


\subsection{Endsystem}
\begin{figure}[tb]
    \missingfigure{Blockdiagramm Endsystems}
    \caption{Blockdiagramm des Imager-Emulator}
    \label{fig:bd_top}
\end{figure}
- Blockdiagram erklären
    - SFP
    -> Nicht auf Entwicklungssystem
    - SD
    - JTAG
    - IO
- Referenz auf Schema und Liste mit Pin und FPGA belegung.

\section{Hardware}
Dieses Kapitel beschreibt die Hardware des Projektes. Es gibt einen kurzen Überblick und verweist auf die Dokumentation von Fabio und die anderen Dokumente für genauere Angaben. Es definiert die Angaben, welche für das Programmieren des SoCs wichtig sind. Und beschreibt die Inbetriebnahme des SoC Teils der Hardware.
-- evt. weglassen, da teil in Kapitel System schon genug erläutert.

\section{Software}
Dieses Kapitel ist der Hauptteil der Arbeit. Es beschreibt den FPGA und Mikrocontroller Code, welcher auf dem SoC läuft und wie dieser getestet wurde. Es ist in die Unterkapitel ARM, FPGA und PC Software aufgeteilt.
\subsection{ARM}
Dieses Kapitel beschreibt, welche Komponenten des ARM Cores gebraucht werden und wie sie konfiguriert sind, wie die Module des ARM Cores aufgebaut sind und auf welchem Core sie laufen.
\subsection{FPGA}
Dieses Kapitel beschreibt die Module, welche auf dem FPGA laufen.
\subsection{PC Applikation}
Dieses Kapitel beschreibt die Software, welche auf dem PC läuft, welche den Imager konfiguriert.


\section{Konfiguration}
Dieses Kapitel beschreibt, wie zusätzliche Konfigurationen hinzugefügt werden können.

\section{Entwicklungsumgebung}
Dieses Kapitel beschreibt, wie der Code für den SoC entwickelt werden kann und worden ist. Dies beinhaltet Vitis, Vivado und wie das Programm auf den SoC geladen werden kann.
\subsection{Vivado}
-Einleitung
    - Für was ist das Tool
    - Bennung der einzelnen Schaltflächen(in Bild)
    - Was kann es alles / aus welchen Teilsystemen besteht es
    - Doku
- IP Integrator
- Simulation
- Syntetisieren
- implementieren
- Hardwaremanager

\subsection{Vitis}
-Einleitung
    - Für was ist das Tool
    - Bennung der einzelnen Schaltflächen(in Bild)
    - Was kann es alles / aus welchen Teilsystemen besteht es
    - Doku
- Plattform Projekt
- System Projekt
- Simples Projekt
- Bootgen

\subsection{Debugging}
- Debugging auf dem Chip
- Die debugging Tools
    - Hardware-Server
    - Vivado
        - ILA
    - Vitis
        - Gnu debugger

\subsection{Workflow}
- Files von Vivado
- Von Vivado in Vitis exportieren
- Files von Vitis
- Do nots (Probleme mit Vitis beschreiben)
- Skripte


\section{Theorie}
Dieses Kapitel beschreibt Funktionalitäten, welche nicht von mir entwickelt worden sind, sondern schon auf dem Modul vorhanden sind. In den einzelnen Unterkapiteln listet es die wichtigsten Konzepte und referenziert auf die Dokumentationen um genauere Informationen zu erhalten. Diese Unterkapitel sollen dazu dienen, dass in den anderen Kapiteln auf diese referenziert werden kann.
\subsection{Enclustra Mercury PE5 Modul}
\subsection{Xilinx SoC}
\subsection{Bootvorgang}
\subsection{Standart Konfiguration der CPU}
\subsection{AXI}

Eventuell werden noch folgende weitere Spezifikationen und Komponenten be\-schrieben.
\subsection{ARM R5}
\subsection{USB Standart}
\subsection{USB Treiber}
\subsection{SerDes}
\subsection{MGT}
\subsection{Debugging}

\section{Erläuterungen}
Dieses Kapitel listet alle Abkürzungen mit den Bedeutungen und einer kurzen Erklärung auf. Zudem erklärt es, wie die verschiedenen Fachwörter zu verstehen sind.

ARM Core,
Core,
FPGA,
Sensor,
XI-Computer,
SoC,
Imager,

Imager-Emulator

P5
LWL
FPGA
Imager
XI-Computer
SerDes
LVDS
Rx
Tx
FIFO




\end{document}