\documentclass{article}
\usepackage{todonotes}
\usepackage{pbox}
\usepackage{tablefootnote}
\title{Dokumentation}
\author{Marc de Bever}
\begin{document}
\maketitle
\tableofcontents

\section{Einleitung}
Dieses Dokument ist ein Teil der Dokumentation des Projektes Imager-Emu\-lator. Dieses Projekt besteht aus drei Teilprojekten. 
Genauer gesagt besteht es aus zwei Bachelor Thesen und einem Projekt 5 (P5). 
Das P5 und eine Thesis laufen parallel und die zweite Thesis wird ein Semester später durchgeführt. Diese Dokumentation ist diejenige von der ersten Thesis, welche parallel mit dem Projekt 5 durchgeführt wird. Das Projekt 5 und die zweite Thesis wird von Fabio Nardo geschrieben und diese Dokumentation ist von mir, Marc de Bever, geschrieben. 

Das Projekt Imager-Emulator wurde von der Firma Varian Medical Systems ausgeschrieben. Das Ziel is es, einen Sensor zu emulieren. Der Sensor gibt Bilder über eine nicht standardisierte LWL Schnittstelle an einen Computer weiter. Der Computer, welcher die Bilder des Sensors entgegen nimmt, rechnet diverse Algorithmen, die unteranderem Pixelfehler erkennen und korrigieren. Jedoch kann dem Sensor nicht gesagt werden, \textit{mach mal 'nen Pixelfehler}. Daher braucht es ein Gerät, um Bilder mit Pixelfehlern zu generieren und an den Computer zu senden. Und dieses Gerät soll in diesem Projekt entwickelt werden.

Da dieses Projekt eine spezielle Konstellation hat, ist die Aufteilung der Teilprojekte wie folgt. Im P5 soll die Hardware entwickelt werden. In der ersten Thesis, also dieser Arbeit, sollen die Entwicklungsumgebungen und das FPGA-Modul in Betrieb genommen werden. Sowie sollen auch die Schnittstellen programmiert werden. Die zweite Thesis soll schlussendlich die Kommunikation mit dem Computer implementieren, die Pixelfehler in die Bilder einbauen und das ganze Projekt abschliessen.

Dieser Bericht dient zum einen dazu, dass im weiterführenden Projekt verstanden werden kann, wie die Entwicklungsumgebung und Schnittstellen funktioniert, deren Möglichkeiten und Grenzen. Zum anderen Dient er um zu diese Arbeit als Thesis zu dokumentieren. Der Bericht ist folgendermassen aufgebaut.

Das zweite Kapitel beschreibt wie die Systeme aussehen. Dafür beschreibt es das Projekt mit drei verschiedenen Systemen. Als erstes das, welches von der Varian schon vorhanden ist. Dieses soll durch dieses Projekt emuliert werden. Das zweite System ist eine Zwischenlösung, damit gleichzeitig die Hardware und die Software entwickelt werden kann. Und das letzte System ist das endgültige Gerät, welches den Sensor der Varian emuliert. Somit soll es einen Top-Down-Blick auf das Projekt gaben. Zusätzlich beschreibt es die Wahl des wichtigsten Komponenten, das FPGA-Modul.

Das dritte Kapitel beschreibt die verschiednen Hardware ein wenig genauer. Die Hardware des engültigen Systemes ist die Arbeit des Projektes 5. Daher werden ist diese in dessen Bericht genauer Beschrieben. In diesem Kapitel sind nur die wichtigsten Punkte erwähnt, welche für das Programmieren relevant sind.

Das vierte Kapitel beschreibt die Software. Diese besteht aus drei Teilen, dem Code für den Mikrocontroller, dem Code für den FPGA und dem Code für die PC-Applikation.
Das fünfte Kapitel beschreibt wie zusätzliche Konfigurationen nachträglich hinzugefügt werden können.
Und zu guter Letzt, das sechste Kapitel beschreibt die Entwicklungsumgebung.

\section{System}
Das Projekt kann in drei Systeme unterteilt werden. Das vorhandene System von Varian ist das erste. Das zweite System ist eine Zwischenlösung um mit der Firmware Entwicklung anzufangen, ohne das die eigene Hardware schon vorhanden ist. Und das dritte System ist das endgültige System, welches das System von Varian emuliert.

\subsection{System Varian}
\begin{figure}[tb]
    \missingfigure{Blockdiagramm System Varian}
    \caption{Blockdiagramm des Systems von Varian}
    \label{fig:bd_varian}
\end{figure}

Das System der Varian besteht aus dem Imager und dem XI-Computer. Wobei diese beiden Blöcke Teil eines Röntgengerätes für medizinische Zwecke sind. Der Imager ist ein Bildsensor für Röntgenstrahlen und sendet die die gemessenen Bilder über ein LWL-Kabel zum XI-Computer. Der XI-Computer empfängt die Bilder und lässt diverse Algorithmen darüber laufen. Unter anderem auch Algorithmen zur Erkennung von Pixelfehlern. Das mit den Algorithmen bearbeitete Bild kann wiederum über Ethernet an einen PC gesendet werden.

Um die Bilder vom Sensor auszulesen, zu digitalisieren und zu übertragen, sitzt auf dem Imager ein FPGA. Dieser sendet die Bilder zum XI-Computer entweder über einen vom FPGA internen oder externen Serialisierer/Deserialisierer, kurz SerDes zu einem LWL-Modul. Der FPGA kommuniziert über einen parallelen Bus mit dem externen SerDes und der die beiden SerDes senden ein LVDS Signal zum LWL-Modul. Um zwischen den beiden SerDes auszuwählen, gehen die Tx Signale auf einen Multiplexer und die Rx Signale auf einen Demultiplexer, dieser wird der Einfachheitshalber nur Mux genannt. Das beschriebene System ist im Blockschaltbild in Figure \ref{fig:bd_varian} zu sehen.

Der Vorteil des internen SerDes ist die Geschwindigkeit. Der externe SerDes arbeitet 1.25Gbps und der interne mit 6Gbps. Die älteren Versionen des Imagers arbeiten nur mit dem externen SerDes und die neueren mit internen. Da stellt sich die Frage, wieso externe SerDes überhaupt gebraucht wird. Beim Einschalten des Imagers ist der noch nicht konfiguriert. Somit wird der externe SerDes gebraucht um den FPGA vom XI-Computer zu konfigurieren. Sobald der FPGA konfiguriert ist, schaltet dieser auf den internen SerDes um und kommuniziert mit dem XI-Computer über diesen. Welche SerDes die verschiedenen Versionen des Imagers besitzen ist in Tabelle \ref{tab:sensorVersionen} ersichtlich.

\begin{table}[tb]
    \caption{Eckdaten der verschiedenen Sensorversionen der Varian}
    \begin{tabular}{|l|l|l|l|l|}
        \hline
        \textbf{Imager} & \textbf{Auflösung} & \textbf{Pattern}$^1$ & \textbf{FPGA} & \textbf{Schnittstelle} \\
        \hline
        DMI$^2$ & 1280x1280 & \pbox[t]{10cm}{b10’1010’1010’1010’1010\\XI: 0xAAA} & \pbox[t]{10cm}{Spartan 3\\XC3S200} & externer SerDes\\
        \hline
        \pbox[t]{10cm}{RTI 1.0$^2$\\(RTI4343L)} & 1280x1280 & \pbox[t]{10cm}{b10’1010’1010’1010’1010\\XI: 0xAAA} & \pbox[t]{10cm}{Spartan 3\\XC3S200} & externer SerDes\\
        \hline
        \pbox[t]{10cm}{RTI 2.0\\(RTI4343iL)} & 3072x3072 &\pbox[t]{10cm}{b10’1010’1001’0101’0101\\XI: 0x955} & \pbox[t]{10cm}{Artix 7\\XC7A100T} & \pbox[t]{10cm}{aktuell:\\externer Serdes\\zukünftig:\\MGT(GTP)} \\
        \hline
        \pbox[t]{10cm}{RTIXL 1.0\\(RTI8643L)} & 6144x3072 & \pbox[t]{10cm}{b10’1010’1001’1001’0101\\XI: 0x995} & \pbox[t]{10cm}{Artix 7\\XC7A200T} & \pbox[t]{10cm}{externer SerDes\\und MGT(GTP)}\\
        \hline
       \end{tabular}
       \begin{tabular}{l}
        $^1$\pbox[t]{10cm}{Das XI wertet nur die letzten 12 bit des Pattern aus. Um das DC-Balancing zu erreichen, müssen trotzdem alle 18 bits korrekt gesendet werden.}\\
        $^2$DMI und RTI 1.0 besitzen exakt die gleiche Elektronik.

       \end{tabular}
    \label{tab:sensorVersionen}
    \end{table}

\subsubsection*{Kommunikation zwischen Imager und XI-Computer}

Man kann zwischen dem XI-Computer und dem Imager von einer Master-Slave Beziehung reden. Der XI-Computer hat die Möglichkeit dem Imager verschiedene Befehle zu senden, welche der Imager daraufhin ausführt. Die Befehle können in drei Gruppen eingeteilt werden. Es gibt die Write-Befehle, welche dem Imager Einstellungen übermitteln, die der Imager in einem Register speichert. Mit den Read-Befehlen kann der XI-Computer diese Einstellungsregister wieder auslesen. Und als letztes gibt es noch den Trigger-Befehl. Die Write-Befehle beinhalten eine Adresse und einen Wert, die Read-Befehle nur einen Wert. Mit dem Trigger-Befehl kann der XI-Computer ein Bild anfordern. Dies hat Vorrang vor Write- und Read-Befehlen. Die genaue Auflistung aller Einstellungsregister und deren Aufgabe kann in der Dokumentation des Imagers entnommen werden. \todo{auf Imager Dokumentation referenzieren}

Der FPGA liest immer Zeile für Zeile die Werte des Sensors aus. Solange kein Trigger-Befehl vom XI-Computer gesendet wird, werden die Werte verworfen. Sobald ein Trigger-Befehl kommt, wartet der FPGA bis er die letzte Zeile ausgelesen hat und verwirft auch diese noch. Wenn der FPGA nun endlich wieder bei der ersten Zeile angelangt, fängt er an das Bild Pixel für Pixel, Zeile für Zeile zu übertragen. Am Anfang des Bildes vor der ersten Zeile sendet der FPGA ein \textit{Frame-Start} Signal. Und vor jeder Zeile überträgt er ein \textit{Line-Start} Signal. Vor der ersten Zeile muss kein zusätzliches Line-Start Signal gesendet werden. Pro Takt wird ein Pixel übertragen. Der FPGA überträgt eine Zeile erst wenn er sie vollständig vom Sensor ausgelesen hat. Somit bleibt zwischen den zu übertragenden Zeilen noch Zeit um etwaige Read-Befehle auszuführen.

Die Read-Befehle werden nur ausgeführt, wenn keine Bilddaten zu senden sind. Daher werden sie in einem FIFO zwischengespeichert und bei Möglichkeit übertragen. Die Read-Befehle dürfen nur zwischen den Zeilen und Bildern übertragen werden und nicht zwischen einzelnen Pixeln. Da es länger dauert eine Zeile von Sensor zu lesen, als eine Zeile an den XI-Computer zu senden, bleibt immer etwas Zeit um die Read-Befehle vom FIFO abzuarbeiten. Wie vor einem neuen Bild und einer neuen Zeile gibt es das \textit{Command} Signal, welches vor den Daten des Read-Befehls gesendet wird. Die Daten eines Read-Befehls bestehen aus den Daten aus dem Einstellungsregister.

\subsubsection*{Wahl des FPGAs}
Das oben beschriebene System soll emuliert werden. Die Vorgabe ist es 100 Bilder speichern zu können. Mit einer maximalen Bildgrösse von 6144x3072x16 ergibt dies etwa 3.5GB Daten. Die Daten sollen via USB auf das Gerät geladen werden und über die LWL-Schnittstelle weiter zum XI-Computer. Daher braucht unser System eine integrierte Hardware für das USB. Die LWL-Schnittstelle ist nicht standardisiert, daher braucht der Emulator eine selber designte Platine. Um Übertragungsgeschwindigkeiten bis 6GBps zu unterstützen muss der Speicher an einer entsprechend schnellen Schnittstelle angeschlossen sein. Da das Layouten einer solchen Schnittstellen zusätzliche Komplikationen, schwierigkeiten und tests verursacht, haben wir uns entschieden ein Modul zu verwenden, auf welchem der Speicher schon angeschlossen ist. Als Recheneinheit ist die Vorgabe einen FPGA von Xilinx zu nehmen. Dies ist vom Auftragsgeber, Varian, vorgegeben, da sie mit diesen FPGAs arbeiten und wir somit auch vorhandenen Code für die LWL-Schnittstelle übernehmen können.

Mit diesen Anforderungen haben wir fünf verschiedene Varianten von den Firmen Enclustra und Trenz-Electronic herausgesucht. Diese sind in der Tabelle \ref{tab:modulVarianten} aufgelistet.

\begin{table}[tb]
    \caption{Verschiedene Vorschläge für ein FPGA Modul}
    \begin{tabular}{|l|l|l|l|l|l|}
        \hline
        & \textbf{Variante 1} & \textbf{Variante 2} & \textbf{Variante 3} & \textbf{Variante 4} & \textbf{Variante 5} \\ \hline

        \textbf{Hersteller} & Enclustra & Trenz-Electronic & Enclustra & Trenz-Electronic & Enclustra \\ \hline
        \textbf{Hersteller} & ME-XU5-5EV-2I-D12E & TE0712-02-35-2I & ME-XU5-4EV-1I-D11E-G1 & TE0803-03-4AE11-A & ME-KX1-160-1C-D10
        \\ \hline
        \textbf{SDRAM} & 4GB & 1GB & 2GB & 2GB & 1GB \\ \hline
        \textbf{FPGA} & Zynq Ultrascale+ XCZU5EV-2SFVC784I & Artix-7 & Zynq Ultrascale+ XCZU4EV-1SFVC784I & Zynq Ultrascale+ & Kintex-7
        \\ \hline
        \textbf{USB} & 2x USB 3.0 & - & 2x USB 2.0 & - & USB 3.0 (zusätzlicher USB-Chip auf Modul)\\ \hline
        \textbf{MGT} & 4 MGT 12.5 & 4 GTP & 4 MGT 12.5 & 4 GTH 16.3 & 4 MGT 6.6 \\ \hline
        \textbf{Preis} & 1010 CHF & 225CHF & 680CHF & 561CHF & 638CHF \\ \hline
        \textbf{Anz. IO} & 178\\ \hline


    \end{tabular}
    \label{tab:modulVarianten}
    \end{table}

    Die erste Variante ist die einzige Variante, welche genug Speicherplatz für alle 100 Bilder hat. Dafür ist sie auch die teuerste. Zusätzlich ist das Modul mit USB ausgerüstet. Variante zwei ist die günstigste, aber hat dafür nur 1GB RAM und kein USB. Dies müsste auf mit einem vom Modul seperaten Chip implementiert werden. Varianten drei und vier sind Mittellösungen, sie haben nur 2GB RAM, kosten dafür auch nicht so viel. Wobei Variante vier auch kein USB auf dem Modul besitzt. Variante fünf ist ist etwa gleich teuer wie die Mittellösungen, jedoch hat sie nur 1GB RAM. Dafür ist sie mit einem einfacheren FPGA und einem externen Chip für das USB ausgestattet. Diese Variante wäre einfacher zu programmieren, da es ein weniger komplexes system ist.

    Die Entscheidung haben wir der Varian überlassen. Die Varian hat sich für die Variante 3 entschieden. Grund für diese Entscheidung ist: "Ein weiteres Entwicklungsboard mit einem Artix 7 bringt uns nichts und ein Modul mit einem Zyncscale bringt und auch für später etwas. Ebenfalls gefällt uns, dass bereits DDR4 Memory und USB3.0 vorhanden ist und somit das Preis-Leistungsverhältnis für uns stimmt."

    Jedoch ist uns da noch ein kleiner Fehler unterlaufen. Und somit hat dieses Modul nur USB 2 und kein USB 3.0. Das Problem ist, das Enclustra Aufgrund von Kompatibilitäten bei den Mercury XU5 Modulen zwei verschiedene Bestückungsvarianten hat. Die einen führen die GTR Lines auf die Stecker und die zweite Variante führt mehr IOs anstatt diese Lines auf die Stecker. Dies war uns auch so klar. Jedoch braucht das USB 3.0 die GTR Lines. Daher kann nur das USB 2.0 gebraucht werden, welche seperat heraus geführt werden. Dies war jedoch, obwohl erst im Nachhinein gesehen, auch in Ordung und daher sind wir bei deiser Variante geblieben.
    
\subsubsection*{Enclustra Mercury XU5}
\begin{figure}[tb]
    \missingfigure{Blockdiagramm des XU5}
    \caption{Blockdiagramm SoC Moduls XU5 von Enclustra}
    \label{fig:bd_xu5}
\end{figure}
Der Enclustra Mercury XU5 Soc ist ein SoC Modul, auf welchem ein Xilinx Zynq Ultrascale+ ZU4EV SoC sitzt. Der Ultrascale ist ein System on Chip(SoC), welcher ein FPGA und ein ARM System hat. Das Modul hat zwei SDRAMs, wobei einer am ARM System hängt und der andere am FPGA. Zusätzlich hat es noch vier LEDs. Das USB 2 vom Ultrascale ist per ULPI mit einem externen Chip verbunden, welcher wiederum auf die Stecker geht. Das Blockschaltbild ist in Abbildung \ref{fig:bd_xu5} zu sehen. Das XU5 hat noch weitere Funktionen. Diese sind jedoch für dieses Projekt nicht relevant und sind daher weder auf dem Blockdiagramm noch im Text beschrieben. Für genauere Informationen kann die Dokumentation des Moduls angeschaut werden. \todo{ref auf Doku von XU5}.

\subsubsection*{Xilinx Zynq Ultrascale+}
\begin{figure}[tb]
    \missingfigure{Blockdiagramm des SoCs}
    \caption{Blockdiagramm des Zynq Ultrascale+ SoCs von Xilinx}
    \label{fig:bd_soc}
\end{figure}

Der Ultrascale ist ein SoC mit einem ARM system und einem FPGA integriert in einem Chip. Das ARM-System wird auch Programmable System (PS) genannt und der FPGA auch Programmable Logic (PL). Das Blockschaltbild ist in Abbildung \ref{fig:bd_soc} zu sehen. Auch hier sind nur die für das Projekt relevante Blöcke abgebildet. 

Das ARM-System besteht aus zwei ARM Cortex-R5 Kernen, vier Cortex-A53 Kernen und einem Grafikkern. Der Grafikkern ist irrelevant für das Projekt und wird daher komplet verschwiegen. Zusätzlich enthält das ARM-System noch eine Configuration Security Unit (CSU) und eine Platform Management Unit (PMU). Diese beiden Blöcke sind für das Booten und während dem Betrieb für die Sicherheit und das Power Management zuständig.

Das Programm läuft auf einem der beiden R5 Kernen. Der Grund, wieso nicht der A53 Kern verwendet wird, ist, dass der A Kern eine MMU besitzt, welche den Adressraum virtualisiert und somit wesentlich komplexer ist.

Der FPGA ist ein Xilinx FPGA von der Ultrascale+ Familie. Er ist über AXI Busse mit dem ARM-System verbunden.

Es gibt vier Hauptdokumentationen über das SoC. Das Overview, das Technical Referenz Manual(TRM), die Software Developer Guide und das Packaging and Pinouts.\todo{ref auf Dokus}


\subsection{Entwicklungssystem}
Da das XU5 nur ein Modul ist, welches nicht selbstständig läuft, braucht es ein zusätzliches Board. Im Verlauf dieses Projektes wird dieses Board entwickelt. Damit jedoch direkt von Anfang an mit dem Entwickeln auf dem SoC begonnen werden kann, haben wir zusätzlich noch das PE1 Board von Enclustra gekauft. 

\subsubsection*{Mercury+ PE1-200 Baseboard}
\begin{figure}[tb]
    \missingfigure{Blockdiagramm des Baseboards}
    \caption{Blockdiagramm des Mercury+ PE1-200 Baseboards von Enclustra}
    \label{fig:bd_pe1}
\end{figure}
Das PE1 Board ist ein Baseboard welches alle zusätzliche nötigen funktionen für das XU5 zu verfügungstellt.
Das Blockdiagramm ist in Abbildung \ref{fig:bd_pe1} zu sehen. Auch hier sind wieder nur die für uns relevanten Blöcke zu sehen. 
Das PE1 hat einen USB Port über welchen das JTAG und UART geführt sind und einen zweiten, welcher auf das USB Interface des SoCs geht. Das JTAG wird auf einen Chip auf dem Board so umgewandelt, dass mit den Entwicklungsumgebungen direkt ohne zusätzliche Hardware per USB auf die Debug-Schnittstelle zugegriffen werden kann. Um zu booten wird die SD Karte gebraucht, für welche das PE1 Board eine Halterung besitzt. Zusätzlich hat das Board noch LEDs und Schalter. Die LEDs und Schalter können als IO des SoCs gebraucht werden. Mit den Schaltern können aber auch Einstellung für den Bootmodus und das Routing der USB Pfade gesetzt werden. Um über USB zu booten müssen die Schalter A1 B2 abgeschaltet sein. Um das JTAG und UART auf die micro USB Büchse zu führen muss Schalter B2 abgeschaltet sein und um das USB Interface des SoCs auf die USB B Büchse zu führen, muss Schalter B1 abgeschalten sein. 
\todo{ref auf Doku}


\subsection{Endsystem}
\begin{figure}[tb]
    \missingfigure{Blockdiagramm Endsystems}
    \caption{Blockdiagramm des Imager-Emulator}
    \label{fig:bd_top}
\end{figure}
- Blockdiagram erklären
    - SFP
    -> Nicht auf Entwicklungssystem
    - SD
    - JTAG
    - IO
- Referenz auf Schema und Liste mit Pin und FPGA belegung.

In Abbildung \ref{fig:bd_top} ist das Blockschaltbild des endgültigen Systems zu sehen. Das selber entwickelte Board hat einen Stecker für das XU5-Modul. Das Modul kann über den SerDes mit dem XI-Computer kommunizieren. Mit dem Mux kann zwischen dem internen und dem externen SerDes gewechselt werden. Und das SFP Modul wandelt das elektrische Signal in ein optisches um. Die Daten können über den Micro-USB Stecker auf den SoC geladen werden. Um zu booten hat es ein SD-Kartenhalter. Zusätzlich hat es noch LEDs und Taster, um falls nötig einfache Ein- und Ausgaben zu betätigen. Um zu debuggen hat es noch einen Stecker für die JTAG-Schnittstelle. Um diese am Computer anzuschliessen braucht es jedoch noch externe Hardware, welche das JTAG auf UART konvertiert. Die JTAG schnittstelle ist nicht auf dem Blockdiagramm, da es nur zu debug-Zwecken dient und während des Betriebs nicht gebraucht wird.

\section{Software}
Dieses Kapitel ist der Hauptteil der Arbeit. Es beschreibt den FPGA und Mikrocontroller Code, welcher auf dem SoC läuft und wie dieser getestet wurde. Es ist in die Unterkapitel ARM, FPGA und PC Software aufgeteilt.
\subsection{ARM}
Dieses Kapitel beschreibt, welche Komponenten des ARM Cores gebraucht werden und wie sie konfiguriert sind, wie die Module des ARM Cores aufgebaut sind und auf welchem Core sie laufen.
\subsection{FPGA}
Dieses Kapitel beschreibt die Module, welche auf dem FPGA laufen.
\subsection{PC Applikation}
Dieses Kapitel beschreibt die Software, welche auf dem PC läuft, welche den Imager konfiguriert.


\section{Konfiguration}
Dieses Kapitel beschreibt, wie zusätzliche Konfigurationen hinzugefügt werden können.

\section{Entwicklungsumgebung}
Es gibt zwei Entwicklungsumgebungen (IDE) von Xilinx, um den Zynq Ultrascale+ SoC zu programmieren und konfigurieren. Das eine Ist Vivado. Vivado ist die IDE um Code für den FPGA zu entwickeln. Mit Vivado kann man IPs im Projekt einfügen, FPGA Code simulieren, syntetisieren, implementieren, den FPGA Konfigurieren und direkt auf dem FPGA debuggen.

Die zweite IDE ist Vitis. Mit Vitis kann man Code für die ARM Kerne schreibe, Bootdateien erstellen, den ARM programmieren, den FPGA konfigurieren und den ARM debuggen. Vitis basiert auf der Eclipse IDE

In diesem Projekt wurden die Versionen Vivado 2019.2 und Vitis 2019 verwendet. Es ist die erste Version von Vitis. Vorher wurde die Xilinx SDK verwendet um Code für den ARM zu schreiben. Ab Vivado 2019.2 ist es jedoch nicht mehr möglich Projekte für die SDK zu exportieren, da die SDK und Vitis unterschiedliche Files brauchen um die Hardware, welche mit Vivado generiert wird, zu importieren. Für beide Tools können mit TCL Skripte geschrieben werden.

Mit den beiden Entwicklungsumgebungen kommt noch das Programm DocNav. Diesem Programm beinhaltet alle Dokumentationen von Xilinx.
\subsection{Vivado}
-Einleitung
    - Für was ist das Tool
    - Bennung der einzelnen Schaltflächen(in Bild)
    - Was kann es alles / aus welchen Teilsystemen besteht es
    - Doku
- IP Integrator
- Simulation
- Syntetisieren
- implementieren
- Hardwaremanager

Vivado ist die IDE für die Entwicklung von FPGAs, sie versteht VHDL und Verilog. Vivado kann entweder im Projektmodus oder nicht im Projektmodus verwendet werden. In diesem Projekt verwenden wir Vivado nur im Projektmodus. Alle Befehle können enteder im GUI oder in der TCL Konsole gegeben werden. Somit ist alles vollständig skriptbar. 

Vivado besteht aus verschiedenen Teilprogrammen. Diese Sind der IP-Integrator, der Simulator, der Syntetisierer, der Implementierer und der Hardwaremanager.

Die Dokumentation von Vivado ist auf verschiedene Dokumente aufgeteilt. Zum starten ist das "Vivado Design Suite User Guide: Using the Vivado IDE" diese Dokumentation referenziert in Kapitel zwei auf die weiteren Dokumentationen der einzelnen Unterprogramme von Vivado.


\subsection{Vitis}
-Einleitung
    - Für was ist das Tool
    - Bennung der einzelnen Schaltflächen(in Bild)
    - Was kann es alles / aus welchen Teilsystemen besteht es
    - Doku
- Plattform Projekt
- System Projekt
- Simples Projekt
- Bootgen

Vitis ist die IDE von Xilinx, um die Processoren zu programmieren. Vitis bassiert auf der Eclipse IDE. 
Von Vivado kann man die Hardware exportieren und in Vitis importieren. Mit der importierten Hardware wird ein Platform-Projekt generiert. auf Grund von diesen Platform-Projekten kann man dann Projekte erstellen. Hier gibt es auch zwei verschiedene Arten. Die System-Projekte und die normalen. Pro System-Projekt können mehrere normale Projekte sein. Jedoch pro Processor nur ein. Jedes System-Projekt ist an ein Platform-Projekt gebunden und jedes normale Projekt in einem System-Projekt und für einen bestimmten Processor.

Kompiliert wird der Code mit den GCC Compilern. Diese werden mit Vitis mitinstalliert und können von Vitis aus gestartet werden. Der kompilierte Code befindet sich in elf Dateien

Mit Hilfe vom Bootgen Tool kann aus den elf-Dateien und Bitfiles generiert werden. Mit diesen kann man den SoC booten.

Die Dokumentation von Vitis ist unter \todo{ref auf doku} zu finden.



\subsection{Debugging}
- Debugging auf dem Chip
- Die debugging Tools
    - Hardware-Server
    - Vivado
        - ILA
    - Vitis
        - Gnu debugger

\subsection{Workflow}
- Files von Vivado
- Von Vivado in Vitis exportieren
- Files von Vitis
- Do nots (Probleme mit Vitis beschreiben)
- Skripte


\section{Erläuterungen}
Dieses Kapitel listet alle Abkürzungen mit den Bedeutungen und einer kurzen Erklärung auf. Zudem erklärt es, wie die verschiedenen Fachwörter zu verstehen sind.

ARM Core,
Core,
FPGA,
Sensor,
XI-Computer,
SoC,
Imager,

Imager-Emulator

P5
LWL
FPGA
Imager
XI-Computer
SerDes
LVDS
Rx
Tx
FIFO




\end{document}